# 手动测试清单

**目的**: 系统地测试所有功能，验证 GitHub issues 的验收标准  
**测试环境**: http://localhost:3000

---

## 测试前准备

1. ✅ 确保开发服务器正在运行
   ```bash
   npm run dev
   ```

2. ✅ 打开浏览器开发者工具 (F12)
   - Console 标签页 - 查看错误
   - Network 标签页 - 查看 API 请求
   - Application 标签页 - 查看 Service Worker

3. ✅ 打开应用: http://localhost:3000

---

## Issue #2: Project Setup ✅ 已验证

**状态**: 可以关闭  
**原因**: 所有验收标准已满足，服务器成功启动

---

## Issue #3: OpenAI Realtime API Integration

### 测试步骤

#### 1. 检查 WebSocket 连接
- [ ] 打开 Network 标签页，筛选 WS (WebSocket)
- [ ] 点击语音按钮
- [ ] 验证: 应该看到 WebSocket 连接到 `ws://localhost:8001`
- [ ] 记录: 连接状态 (成功/失败)

#### 2. 检查 API Key 配置
- [ ] 查看 Console 是否有 "API key not configured" 错误
- [ ] 如果有错误，需要配置 OpenAI API key

#### 3. 测试音频流 (需要 API key)
- [ ] 点击语音按钮开始录音
- [ ] 说话几秒钟
- [ ] 验证: 应该看到音频数据通过 WebSocket 发送
- [ ] 验证: 应该收到 AI 的音频响应

### 验收标准检查

- [ ] WebSocket 服务器建立
- [ ] OpenAI Realtime API 连接和认证
- [ ] 双向音频流 (PCM16 格式)
- [ ] 会话生命周期管理
- [ ] 错误处理和自动重连
- [ ] 音频格式转换
- [ ] 速率限制和连接节流
- [ ] 环境变量配置

### 测试结果
**状态**: ⬜ 待测试  
**阻塞**: 需要 OpenAI API key  
**笔记**: 

---

## Issue #4: Web Audio API Implementation

### 测试步骤

#### 1. 麦克风权限
- [ ] 点击语音按钮
- [ ] 验证: 浏览器应该请求麦克风权限
- [ ] 点击 "允许"
- [ ] 记录: 权限请求是否正常显示

#### 2. 实时音频捕获
- [ ] 允许麦克风权限后
- [ ] 验证: 语音按钮状态应该变为 "active"
- [ ] 说话
- [ ] 验证: 应该看到音频可视化 (波形)

#### 3. 音频可视化
- [ ] 在录音时观察界面
- [ ] 验证: 应该有实时波形显示
- [ ] 验证: 波形应该随声音变化

#### 4. 音频播放
- [ ] 等待 AI 响应 (需要 API key)
- [ ] 验证: 应该听到 AI 的语音
- [ ] 验证: 音频播放流畅，无卡顿

#### 5. 语音活动检测 (VAD)
- [ ] 开始录音
- [ ] 保持安静 3 秒
- [ ] 说话
- [ ] 验证: 应该只在说话时检测到语音活动

#### 6. 音频设备选择
- [ ] 打开设置面板
- [ ] 查找音频设置
- [ ] 验证: 应该能选择不同的麦克风/扬声器

### 验收标准检查

- [ ] 麦克风权限处理和用户同意流程
- [ ] 实时音频捕获使用 getUserMedia()
- [ ] PCM16 音频格式转换
- [ ] AI 响应的音频播放系统
- [ ] 语音活动检测 (VAD)
- [ ] 实时波形显示的音频可视化
- [ ] 音频设备选择和配置
- [ ] 回声消除和噪声抑制

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## Issue #5: Voice Button Component

### 测试步骤

#### 1. 按钮显示
- [ ] 查看主界面
- [ ] 验证: 应该看到一个大的圆形语音按钮
- [ ] 验证: 按钮应该有动画效果

#### 2. 状态: Idle (空闲)
- [ ] 初始状态
- [ ] 验证: 按钮应该显示麦克风图标
- [ ] 验证: 按钮应该有呼吸动画或脉冲效果
- [ ] 悬停: 验证有悬停效果

#### 3. 状态: Connecting (连接中)
- [ ] 点击按钮
- [ ] 验证: 按钮应该显示加载/连接动画
- [ ] 验证: 应该有旋转或脉冲效果

#### 4. 状态: Active (活动)
- [ ] 麦克风权限允许后
- [ ] 验证: 按钮应该变为 "录音中" 状态
- [ ] 验证: 应该有不同的颜色 (如红色或青色)
- [ ] 验证: 应该有持续的动画

#### 5. 状态转换
- [ ] 测试: Idle → Connecting → Active
- [ ] 验证: 所有转换应该平滑 (0.3s 过渡)
- [ ] 再次点击按钮停止
- [ ] 验证: Active → Idle 转换平滑

#### 6. 键盘访问
- [ ] 使用 Tab 键导航到按钮
- [ ] 验证: 应该有焦点指示器
- [ ] 按空格键
- [ ] 验证: 应该激活/停用录音

#### 7. 无障碍功能
- [ ] 右键点击按钮 → 检查元素
- [ ] 验证: 应该有 aria-label 属性
- [ ] 验证: 应该有适当的 role 属性

### 验收标准检查

- [ ] 创建了具有多个视觉状态的动画语音按钮
- [ ] 实现了状态机: idle → connecting → active
- [ ] 状态之间有平滑的 CSS 动画过渡
- [ ] 处理语音激活/停用的点击事件
- [ ] 为麦克风访问状态提供视觉反馈
- [ ] 支持键盘访问 (空格键激活)
- [ ] 为每个状态显示适当的图标
- [ ] 为活动状态实现脉冲/呼吸动画

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## Issue #6: Conversation Interface

### 测试步骤

#### 1. 消息显示
- [ ] 开始对话 (需要 API key)
- [ ] 说一些话
- [ ] 验证: 应该看到你的消息显示为气泡
- [ ] 验证: 用户消息应该在右侧
- [ ] 验证: AI 消息应该在左侧

#### 2. 消息类型
- [ ] 验证: 用户消息有不同的样式
- [ ] 验证: AI 消息有不同的样式
- [ ] 验证: 系统消息 (如果有) 有不同的样式

#### 3. 实时更新
- [ ] 发送消息
- [ ] 验证: 消息应该立即出现，无需刷新页面
- [ ] 验证: 消息应该有平滑的进入动画

#### 4. 打字指示器
- [ ] 发送消息后
- [ ] 验证: 应该看到 "AI 正在输入..." 指示器
- [ ] 验证: 指示器应该有动画点点点

#### 5. 音频波形可视化
- [ ] 录音时
- [ ] 验证: 应该看到实时波形显示
- [ ] 验证: 波形应该随你的声音变化

#### 6. 自动滚动
- [ ] 发送多条消息
- [ ] 验证: 界面应该自动滚动到最新消息
- [ ] 手动向上滚动
- [ ] 发送新消息
- [ ] 验证: 应该有 "滚动到底部" 按钮

#### 7. 消息时间戳
- [ ] 查看消息
- [ ] 验证: 每条消息应该有时间戳
- [ ] 验证: 时间戳格式友好 (如 "2 分钟前")

#### 8. 消息状态
- [ ] 发送消息
- [ ] 验证: 应该看到 "发送中" 状态
- [ ] 验证: 发送成功后状态变为 "已发送"
- [ ] 如果失败: 验证显示 "错误" 状态

### 验收标准检查

- [ ] 为用户和 AI 消息创建消息气泡显示
- [ ] 实现无需刷新页面的实时消息更新
- [ ] AI 生成响应时添加打字指示器
- [ ] 语音输入期间显示音频波形可视化
- [ ] 支持不同的消息类型 (文本、音频、系统)
- [ ] 自动滚动到最新消息
- [ ] 显示消息时间戳
- [ ] 实现消息状态指示器 (发送中、已发送、已接收)

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## Issue #7: AI Personality System

### 测试步骤

#### 1. 打开设置面板
- [ ] 查找设置按钮 (通常是齿轮图标)
- [ ] 点击设置按钮
- [ ] 验证: 设置面板应该打开

#### 2. 个性选择器
- [ ] 在设置面板中查找 "Personality" 标签
- [ ] 点击 "Personality" 标签
- [ ] 验证: 应该看到个性选择器

#### 3. 查看 3 个预设
- [ ] 验证: 应该看到 3 个个性选项:
  - [ ] Friendly Companion (友好伴侣)
  - [ ] Professional Assistant (专业助手)
  - [ ] Playful Friend (俏皮朋友)
- [ ] 验证: 每个选项应该有描述

#### 4. 个性预览
- [ ] 悬停或点击每个个性
- [ ] 验证: 应该看到个性的详细描述
- [ ] 验证: 应该看到语音设置预览

#### 5. 切换个性
- [ ] 选择 "Professional Assistant"
- [ ] 验证: 选择应该被保存
- [ ] 验证: 界面应该反映选择 (如高亮)

#### 6. 测试个性差异 (需要 API key)
- [ ] 选择 "Friendly Companion"
- [ ] 开始对话，说 "Hello"
- [ ] 记录 AI 的响应风格
- [ ] 切换到 "Professional Assistant"
- [ ] 再次说 "Hello"
- [ ] 验证: AI 的响应风格应该不同

#### 7. 个性持久化
- [ ] 选择一个个性
- [ ] 刷新页面
- [ ] 验证: 选择的个性应该被保留

#### 8. 实时切换
- [ ] 在对话中途切换个性
- [ ] 验证: 切换应该平滑，无需重启对话

### 验收标准检查

- [ ] 创建 3 个不同的个性预设 (友好、专业、俏皮)
- [ ] 实现个性选择界面
- [ ] 构建动态提示管理系统
- [ ] 支持每个个性的语音特征匹配
- [ ] 启用对话期间的实时个性切换
- [ ] 存储用户的首选个性设置
- [ ] 提供个性预览/演示功能
- [ ] 实现个性之间的平滑过渡

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## Issue #8: Data Persistence & Export

### 测试步骤

#### 1. 对话历史存储
- [ ] 进行一次对话 (需要 API key)
- [ ] 刷新页面
- [ ] 验证: 对话历史应该被保留

#### 2. 对话列表
- [ ] 查找对话历史/列表按钮
- [ ] 点击查看对话列表
- [ ] 验证: 应该看到之前的对话

#### 3. 创建新对话
- [ ] 点击 "新对话" 按钮
- [ ] 验证: 应该开始一个新的空白对话

#### 4. 查看对话
- [ ] 从列表中选择一个对话
- [ ] 验证: 应该加载该对话的所有消息

#### 5. 删除对话
- [ ] 选择一个对话
- [ ] 点击删除按钮
- [ ] 验证: 应该有确认提示
- [ ] 确认删除
- [ ] 验证: 对话应该被删除

#### 6. 导出功能 - JSON
- [ ] 打开设置面板
- [ ] 查找 "Export" 或"导出" 选项
- [ ] 选择 JSON 格式
- [ ] 点击导出
- [ ] 验证: 应该下载一个 .json 文件
- [ ] 打开文件验证内容正确

#### 7. 导出功能 - Markdown
- [ ] 选择 Markdown 格式
- [ ] 点击导出
- [ ] 验证: 应该下载一个 .md 文件
- [ ] 打开文件验证格式正确

#### 8. 导出功能 - Text
- [ ] 选择 Text 格式
- [ ] 点击导出
- [ ] 验证: 应该下载一个 .txt 文件
- [ ] 打开文件验证内容可读

#### 9. 对话搜索
- [ ] 在对话列表中查找搜索框
- [ ] 输入搜索词
- [ ] 验证: 应该过滤显示匹配的对话

#### 10. 对话元数据
- [ ] 查看对话详情
- [ ] 验证: 应该显示:
  - [ ] 创建时间
  - [ ] 消息数量
  - [ ] 使用的个性
  - [ ] 音频时长 (如果有)

### 验收标准检查

- [ ] 设置 SQLite 数据库用于对话历史存储
- [ ] 实现对话 CRUD 操作 (创建、读取、更新、删除)
- [ ] 构建对话导出功能 (JSON、markdown、文本格式)
- [ ] 添加 Redis 本地缓存层用于最近对话
- [ ] 创建对话搜索和过滤功能
- [ ] 实现数据隐私控制 (自动删除选项)
- [ ] 支持对话元数据 (时间戳、使用的个性、音频时长)
- [ ] 提供对话统计和洞察

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## Issue #9: PWA & Deployment

### 测试步骤

#### 1. Service Worker 注册
- [ ] 打开 DevTools → Application 标签页
- [ ] 查看 Service Workers 部分
- [ ] 验证: 应该看到已注册的 service worker
- [ ] 验证: 状态应该是 "activated"

#### 2. Web App Manifest
- [ ] 在 Application 标签页中查看 Manifest
- [ ] 验证: 应该看到应用信息:
  - [ ] 名称: "Cyber Girlfriend AI"
  - [ ] 短名称: "CyberGF"
  - [ ] 图标
  - [ ] 主题颜色

#### 3. PWA 安装提示
- [ ] 使用 Chrome/Edge 浏览器
- [ ] 验证: 应该看到安装提示 (可能在地址栏或页面上)
- [ ] 点击安装
- [ ] 验证: 应用应该安装到桌面/应用列表

#### 4. 离线功能
- [ ] 打开 DevTools → Network 标签页
- [ ] 勾选 "Offline" 复选框
- [ ] 刷新页面
- [ ] 验证: 应用应该仍然加载 (显示缓存的内容)
- [ ] 验证: 应该有离线指示器

#### 5. 缓存策略
- [ ] 在 Application → Cache Storage 中查看
- [ ] 验证: 应该看到缓存的资源:
  - [ ] HTML, CSS, JS 文件
  - [ ] 图片和图标
  - [ ] API 响应 (如果有)

#### 6. 推送通知 (如果实现)
- [ ] 查找通知权限请求
- [ ] 允许通知
- [ ] 验证: 应该能接收通知

#### 7. 独立窗口模式
- [ ] 安装 PWA 后
- [ ] 从桌面/应用列表启动
- [ ] 验证: 应该在独立窗口中打开 (无浏览器 UI)

### 验收标准检查

- [ ] 实现用于缓存和离线功能的 service worker
- [ ] 创建用于 PWA 安装的 web app manifest
- [ ] 启用带缓存对话的离线模式
- [ ] 配置 Cloudflare Workers 部署
- [ ] 设置 WebSocket 连接的边缘优化
- [ ] 实现应用安装提示和处理
- [ ] 添加对话更新的推送通知支持
- [ ] 配置生产环境变量和密钥

### 测试结果
**状态**: ⬜ 待测试  
**笔记**: 

---

## 测试完成后

### 1. 更新 TEST_RESULTS.md
- [ ] 记录所有测试结果
- [ ] 标记通过/失败的测试
- [ ] 记录发现的 bug

### 2. 创建 Bug 列表
- [ ] 列出所有发现的问题
- [ ] 按优先级排序
- [ ] 创建修复计划

### 3. 关闭已验证的 Issues
- [ ] 对于每个通过所有测试的 issue:
  - [ ] 在 GitHub 上添加测试结果评论
  - [ ] 关闭 issue

### 4. 创建 Pull Request (如果需要)
- [ ] 为重大功能创建 PR
- [ ] 添加测试证据
- [ ] 请求代码审查

---

**测试人员**: _______________  
**测试日期**: _______________  
**测试时长**: _______________

